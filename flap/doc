but: compilateur
hopix -> x86_64
raffiner le compilateur avec des optimisations

nous allons respecter le ABI C
nous allons faire de la meilleure analyse statique

flapicup - une personne va gagner
	le code le plus éfficace (selon un certain benchmark)

optimisations
	register allocation
	pattern matching
	dead code removal
	common subexpr extraction
	tail call

haskell - doesn't check exhaustivity of pattern matching

----

phases de compilation

(* list length in hopix *)
def len (l) = case l
{
	| Nil => 0
	| Cons (_, xs) => 1 + len (xs)
}

hobix - pas de pattern matching (type algébrique)

block - memory zone in heap; representation of object constructors
	first cell - identifier (e.g. 0 for Nil, 1 for Cons)
	next cells - arguments of the constructor

(* hobix *)
def len (l) =
	if l[0] = 0 then
		0
	else (* if l[0] = 1 then *)
		let xs = l[2] in
		1 + len (xs)

pattern matching is naturally translated to decision tree

def add (x) =
	let z = 2 * x in
	fun (y) -> x + y * z

fopix - explicitation of closures

closure - function pointer and environment (free variables used in the function)

(* fopix *)
def anonymous (y, env) =
	env[2] + y * env[1]
def add (x) =
	let z = 2 * x in
	[ ptr_code(anonymous); z; x ]

retrolix
	RTL - register Transfer Language

def fact (n) =
	if n = 0 then 1 else n * fact (n - 1)

retrolix - depends on platform; uses ABI

only simple expressions
goto instead of function calls

(* retrolix *)
def fact ()
	locals tmp
	l0: cmp %rdi, 0 -> l1, l2
	l1: mov %rax, 1 -> l3
	l3: ret
	l2: mov tmp, %rdi -> l4
	l4: mov %rdi, %rdi - 1 -> l5
	l5: call fact -> l6
	l6: mov %rax, (mul tmp, %rax) -> l7
	l7: ret

GNU assembly syntax

----

x86_64

Instruction Set Architecture (ISA)
	abstraction that allows portability between a group of CPUs
microarchitecture - implementation techniques for a given ISA in a given CPU

RISC vs CISC
	R - reduced
		small number of mostly orthogonal instructions
		clear separation between arithmetic-logic instructions and memory instructions
	C - complex

backward compatible - retrocompatible

iri.fr
	Notes on x86-64 programming

état du processeur
* registers
* memory (including stack)

registers
16 integer registers (64-bit; s/r/e/ for 32-bit)
%rax, %rbx, %rcx, %rdx, %rbp, %rsp, %rdi, %rsi
%r8, %r9, ..., %r15          // exclusive for x86_64
bp - base pointer
sp - stack pointer
di - destination index
si - source index

%eax, %ebx, %ecx, %edx, %edp, %esp, %edi, %esi - uses the same physical location as the lower 32 bits of the 64-bit registers
%ax, ... - 16bit registers (lower part of 32 bits)

little endian

we'll not talk about floating point

%rip - instruction pointer (program counter)
%rflags - bit flags; info about last operation
%rbp - frame pointer

address name
	OFFSET(BASE, INDEX, SCALE)
	OFFSET + BASE + INDEX * SCALE

	OFFSET - immediate (constant or label)
	BASE - register
	INDEX - register (optional)
	SCALE - \in {1, 2, 4, 8} (optional; default: 1)

constants
	prefixed by $

memory transfer
	mov src, dst			// gnu
	mov dst, src			// intel

	variants: movq (64b), movl (32b), movw (16b), movb (8b)

	movq $42, %rax			// %rax = 42
	movq %rbx, -8(%rsp)		// (%rsp - 8) = %rbx

	// not allowed (only 1 memory operation per instruction)
	movq 0(%rax), 0(%rbx)
	movq (%rax), (%rbx)

ABI System V stack and call convention

stack - grows down
%rsp - top of the stack (used in function calls); must be 8-byte aligned
%rbp - pointer to the stack frame

stack instructions
	pushq %rax				// decrease %rsp with 8B (64b) and store %rax at the space
	popq %rax				// store the value at the stack to %rax and increase %rsp with 8B (64b)

	// pushq can be implemented with several simpler instructions
	subq $8, %rsp			// subtract 8 from %rsp and store in %rsp
	movq %rax, (%rsp)

	// does same as the above
	movq %rax, -8(%rsp)
	subq $8, %rsp

ALU
	addq src, dst
	subq src, dst
	xorq src, dst

	side effect: %rflags may change

%rflags bit		meaning					name
0				unsigned wrap-around	CF (carry flag)
1				is even					PF (parity)
6				is zero					ZF
7				is negative				SF
11				signed overflow			OF

jmp foo						// jump to label foo
jmp *%rax					// jump to instruction address %rax (copies %rax into %rip)

conditioning
	cmpq src1, src2
		calculates src2 - src1
		updates %rflags
		throws away the result

	cmp %rbx, %rax
	je foo					// jump to label foo if ZF (if zero)

	there are different jumps (for different sign and different signedness)

function call
	call foo
	call *%rax

	like jmp, but also stores return address
	%rip is pushed to the stack

	ret
		pops the address from the top of the stack and jumps there

	we need to push the frame pointer of the calling function

	func: // function call
		pushq %rbp
		movq %rsp, %rbp
		subq $16, %rsp
		// ...
		addq $16, %rsp
		popq %rbp
		ret

	%rsp may move
	%rbp won't move in the function call; we can use it to access local variables

	caveat:
		before a function call, 8(%rsp) needs to be 16-byte aligned

	function args:
		rdi, rsi, rdx, rcx, r8, r9
	return:
		rax

	the address of a function must be well-aligned

division
	compliquée; exige des régistres spécifiques

TD
	peter.habermehl@irif.fr

####

retrolix -> x86_64

notion de variable
	variables globales
	paramètres de fonction
	variables locales

chaque instruction a un label
permet 2 références mémoire dans une instruction

lvalue et rvalue
lvalue - variables and registers

function
	the function to be called is rvalue

Load == copy

assume retrolix programs use registers properly
	r15 - jamais utilisé (a.k.a. scratch) - on peut utiliser pour temp

in x86_64
	JmpI - indirect jump (with register or memory)

	type address - the OFFSET operator in GNU assembly

InstructionSelector
	functions
FrameManager
	info about variables (local? global? etc.)

frame_descriptor
	number of args
	size on stack
	map ...

globals
	in assembly treated as pointers to the address where the value is stored	
	e.g.
	g:
		.quad 0		# set global g to 0 at startup
	movq (g), %rbx

bin - generic function for bin operations
	takes an argument instruction name and generates the sequence of instruction to perform this operation

valid retrolix code has "ret" instruction at the end of each function
global initializations should end with "ret"

il faut gérer les régistres qui sont écrasées

idiv <s>
	utilise la concaténation de %eax, %edx
	the result is quotient and remainder

----

fopix -> retrolix

fopix features:
	memory management
	i/o
	comparing strings

higher level languages need more runtime (fr: environment d'execution)

allocate_block - allocates block with a given size
read_block - reads block at a given location (with given index)
write_block - writes block value at a given location (with given index)
no need to free memory (we'll write gc)

assignment uses write_block
	block_e[index_e] := val_e
	translated to: write_block(block_e, index_e, val_e)

expressions
	literal, variable, define, function call, unknown function call, while, ifthenelse, switch

arithmetic and boolean operations are implemented as function calls

short circuit for if

il y a du masquage de variables

things to handle:
	memory management
	expression translation
	scope management
	preserving register values when necessary
	boolean representation

rename local variables

recursive function

----

hobix -> fopix

closures
	techniques: explicit closures, lambda lifting

	overapplication of function - pass the rest of the arguments to the return value

	closure impact performance if implemented naïvely

when we translate, it's not just line to instructions. we need to add a global function sometimes
	translation:	expression -> (expression) x (def list)

recursive calls - we need a pointer to the function from inside (we can pass it as part of the closure)

mutually recursive functions
	remember which functions are recursive and use this from inside a function to translate the function call


